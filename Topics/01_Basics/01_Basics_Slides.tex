\documentclass{beamer} % [aspectratio=169]
\usetheme{ucl}
\setbeamercolor{banner}{bg=brightblue}
\setbeamersize{description width=2em}
\setbeamertemplate{navigation symbols}{\vspace{-2ex}} 

\usepackage[T1]{fontenc} % Turn Â£ into $
\usepackage{minted}
\usemintedstyle{emacs}

\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{url}

\usepackage{natbib}
\usepackage{bibentry}
\usepackage{url}

\newcommand\emc[1]{\textcolor{brightblue}{\textbf{#1}}}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\author{Prof.\ George Danezis \\ University College London, UK}
\title{Basics of Computer Programming \\ \& Software Engineering.}
\subtitle{ENGS102P: Design and Professional Skills }
% \institute{}
\date{Term 1, 2017}


\begin{document}
\nobibliography*


\frame{
\titlepage
}

\section{Introduction}

\frame{
\frametitle{Introducing ENGS102P.}

The ENGS102P `Design and Professional Skills' course has 3 objectives:
\begin{itemize}
\item Teach the basics of \emc{programming in Python}.
\item Introduce basic \emc{Computer Science} concepts.
\item Accustom you to basic \emc{Software Engineering} practices.
\item Expose you to key \emc{ethical and social debates} surrounding computing.
\end{itemize}

} 


\frame{
\frametitle{What is Computer Science \& Software Engineering?}

Computer Science:
\begin{itemize}
\item Studies the nature of \emc{information, computation, complexity} of algorithms, and their \emc{correctness}.
\item Deep mathematical foundations, including logic, algebra and probability theory.
\end{itemize}

Software Engineering:
\begin{itemize}
\item Studies how teams can repeatably \emc{build high quality, correct, usable and efficient software}, to meet \emc{people's needs}.
\item Programming is a foundational and important part of it.
\end{itemize}

The two are interlinked, and we will study them together.
} 

\frame{
\frametitle{Programming \& languages (I).}

Programming \& Programmability: 
\begin{itemize}
	\item A device is programmable if it allows a programmer (developer, engineer) to \emc{alter its behavior}. This is the act of programming.
	\item We usually think of a device as programmable, when the \emc{program itself takes the form or information}, rather than physical modification.
	\item A computer is the \emc{ultimate programmable device}, and can execute all computations. Simpler ones include video recording devices, microwave ovens, and alarm clocks.
	\item \emc{Programming is specializing} a device to solve \emc{a problem that people have}.
\end{itemize}
}

\frame{
\frametitle{Programming \& languages (II).}

Programming Languages:
\begin{itemize}
	\item The \emc{information describing the program} (code), is expressed in a programming language.
	\item \emc{Trivial} programming languages: button presses to program an alarm clock. They are very \emc{low-level ways}, and lead to errors and inflexibility.
	\item Full computers are programmed in \emc{higher-level formal languages}. Programmers may express their intent directly, build complex abstractions, and compose programs from smaller fragments.
	\item Programming languages are formal languages but also \emc{human languages}. Programmers, use them to \emc{express and communicate their intent}.
\end{itemize}

}


\frame{
\frametitle{Why Python?} 
\begin{itemize}
	\item \emc{Real-world}, widely used programming language (5th in TIOBE ranking.)
	\item \emc{Multi-paradigm}: scripting, procedural, functional elements, object oriented, generics.
	\item Extensive \emc{eco-system} of tools and libraries. Great documentation.
	\item Significant \emc{industrial uses}.
	\item \emc{High-productivity}, and perfect for rapid prototyping.
\end{itemize}

Other languages you might want to learn:
\begin{itemize}
\item Lower-level: Rust (Hip!), C++, \emc{C}.
\item Static typing: Go (Hip!), \emc{Java}, C\#.
\item Web: Javascript (Hip!).
\item Functional: \emc{Haskell}, Scala (Hip!)
\end{itemize}

}

\begin{frame}[fragile]
\frametitle{Using Python interactively.} 

\begin{itemize}
	\item Install Python (\url{https://www.python.org/about/gettingstarted/})
	\item Open a command line console, and run the Python interpreter.
	\item Type your fist command: \mint{Python}{print("Hello World!")}
	\item You should see it executing!

\begin{Verbatim}[fontsize=\footnotesize]
george$ python3
Python 3.5.2 (default, Nov 17 2016, 17:05:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello World!")
Hello World!
>>>
\end{Verbatim}

\end{itemize}

\end{frame}


\frame{
\frametitle{Key resources and tools.} 

The interactive interpreter is only good for quick experimentation.
\begin{itemize}
	\item \emc{Code editor}: atom (hip!), Sublime (hip last year!), Visual Studio Code. Must haves: Good syntax highlighting, good handling of files \& folders, whitespace, looks very cool.
	\item Browser with \emc{Python Documentation}: \url{https://docs.python.org/3/}. (including \emc{Python tutorial} and \emc{Library reference}.)
	\item \emc{Command line} \& learn how to use it. \url{https://www.lynda.com/Linux-tutorials/Learn-Linux-Command-Line-Basics/435539-2.html}
	\item Q\&A in browser: \emc{Stack Overflow}. \url{https://stackoverflow.com/}
\end{itemize}
}

\frame{
\frametitle{Well being.} 

\begin{itemize}
\item Approach the physical activity of programming with \emc{professionalism}.
\item Think of the \emc{ergonomics} of your physical environment: chair height, desk, posture, keyboard style, monitor type and positioning.
\item Make sure you \emc{enjoy your working environment}: light, sounds, distractions.
\item \emc{Drink water}. \emc{Take breaks}, at least every hour.
\item \emc{Keep fit}: core muscles support your back and arms. 
\end{itemize}

}

\begin{frame}[fragile]
\frametitle{The `Hello World!' program in Python.} 

Programs live in files. A simple Python program:

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/hello_world.py}

Execute your first program, by running:
\begin{Verbatim}
$ python3 hello_world.py
Hello World!
\end{Verbatim}

\end{frame}

\begin{frame}
\frametitle{Comments and Whitespace.}

Comments are not executed by Python, but form part of your program.
\begin{itemize}
\item Comments \emc{communicate intent} to your future self and others.
\item Express in comments concepts you cannot directly express in code.
\item Prefer to express concepts directly in code!
\item Keep comments local to the relevant code.
\item Do not overcomment, and avoid duplicate, redundant or wrong comments. Every line of comment will have to be maintained in the future.
\end{itemize}

Python is \emc{sensitive to indentation} using whitespace. Use 3 or 4 spaces (not a tab) to indent blocks of code. More about this later \ldots.

\end{frame}

\begin{frame}
\frametitle{How do we know a program does what it should?}

\emc{Correctness is most important problem} in software engineering and computer science!

\vspace{3mm}
\emc{Testing is the key technique} to produce high quality, correct programs. It is an activity that is continuous, and performed in parallel with programming.

\vspace{3mm}
Complimentary techniques for ensuring program correctness include \emc{formal verification}. Those are more expensive, but necessary to reason about very complex problems.

\vspace{3mm}
Finally, formal periodic \emc{code reviews}, or continuous reflection through \emc{pair programming} also improve quality.

\end{frame}


\frame{
\frametitle{Test Code Continuously.} 

\emc{Testing} is the most important technique to gain confidence a program does what it should:
\begin{itemize}
	\item Unit Test every 2-5 lines of code you write. Think how to \emc{test every snippet of code} just before, while, or just after you write it.
	\item Use a mature \emc{tool for testing} your programs. We will use \texttt{pytest}. \url{https://docs.pytest.org/}.
	\item Different testing techniques for code correctness, integration, security, performance and user experience.
	\item Shortcomings of testing: \emc{lack of completeness}.
\end{itemize}

}

\frame{
\frametitle{Testing the `Hello World!' program.} 

\emc{Tests are snippets of code} executing parts of your program. Eg.\ the test of the simple Python program is:

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/test_hello_world.py}

We run the \emc{test suit}, by executing \texttt{pytest test\_hello\_world.py} on the command line.


}

\frame{
\frametitle{Code documentation and its tests. } 

\emc{Code documentation} is not executed, but forms part of the program. It is useful to your future self, or others that want to use part of your program. Hence, \emc{document reusable units of code}.

	\inputminted[
		xleftmargin=1.4em,
		highlightlines={6-7},
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize, 
		linenos
	]{python}{src/hello_world_doc.py}

You must \emc{test code in documentation}. Through \texttt{pytest -vs --doctest-modules test\_hello\_world.py}.

}


\begin{frame}[fragile]

\frametitle{Example of a successful test run. }

Executing \texttt{pytest} runs all tests in functions named \texttt{test\_*} and documentation strings.

\begin{Verbatim}[fontsize=\scriptsize]
$ pytest -vs --doctest-modules src/*hello*.py
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.2.1, py-1.4.34, pluggy-0.4.0 -- c:\users\george\appdata\local\programs\python\python35\python.exe
cachedir: .cache
rootdir: C:\Users\george\Desktop\projects\Design_and_Professional_Skills\Topics\01_Basics, inifile:
collecting ... collected 3 items

src/test_hello_world.py::test_hello_world PASSED
src/hello_world_doc.py::hello_world_doc.hello_world PASSED
src/test_hello_world.py::test_hello_world PASSED

========================== 3 passed in 0.03 seconds ===========================
\end{Verbatim}

\end{frame}

\frame{
\frametitle{Summary and next steps.}

The rhythm-of-the-programming-business:
\begin{itemize}
	\item \emc{Think} of the problem $\rightarrow$ \emc{Code} feature (2-5 lines) $\rightarrow$ \emc{Write test} for feature $\rightarrow$ Run \emc{all} tests $\rightarrow$ Fix until \emc{all tests pass} $\rightarrow$ Think \ldots
	\item Working programmers \emc{run tests a few times per minute}.
	\item Testing practice imposes an \emc{incremental approach} to software building.
	\item Professional standards: aspire to deliver programs with \emc{zero bugs}. 
	Remember that \emc{`bugs' may cost millions or even kill}.
\end{itemize}

\vspace{5mm}
Still to cover: functions and function calls (\texttt{def}, \texttt{()}), modules (\texttt{from}, \texttt{import}) and a lot more python \ldots

}

\section{Algorithms \& Python}

\begin{frame}
\frametitle{What is an `algorithm'.} 

An algorithm describes a sequence of steps leading to the solution of a computational problem.

\vspace{5mm}
You are familiar with a number of algorithms, from A-level maths:
\begin{itemize}
\item How to perform integer or real number addition, subtraction, multiplication and division by hand.
\item How to find the roots of a quadratic equation $ax^2+bx+c = 0$.
\item How to expand brackets for $(a+b)(c+d) = ?$
\end{itemize}

\begin{block}{Beyond maths \ldots}
Once we express wider parts of the world as information, algorithms can solve more exciting tasks: eg.\ rendering a 3D scene in a computer game, encrypt communications, build interactive social networks on-line, and program cars to drive autonomously.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Euclid's algorithm for computing the GCD. (I)} 

Euclid of Alexandria (300 BC), like many Hellenistic scholars, was interested in properties of integer and rational numbers. 

\vspace{5mm}
Finding the \emc{greatest common denominator} (GCD) allowed them to simplify fractions:

\vspace{5mm}
Eg.\ $\frac{390253}{228769} = \frac{29 \cdot 13457}{17 \cdot 13457} = \frac{29}{17}$ since $GCD(390253, 228769) = 13457$.

\vspace{5mm}
But how to compute the $GCD(\cdot, \cdot)$ function without resorting to factoring the numbers (which turns out to be a hard problem for large numbers)?

\end{frame}

\begin{frame}
\frametitle{Euclid's algorithm for computing the GCD. (II)} 

\begin{block}{Euclid's algorithm for computing the GCD (in prose)}
\begin{itemize}
\item Consider the two integers for which you want to find the GCD.
\item Take the smaller one, and subtract it from the larger one. 
\item Replace the larger one with this result, and keep the smaller one, as your two new numbers. 
\item Repeat until the two numbers are equal. 
\item Once they are, the resulting (equal) numbers are the GCD.  
\end{itemize}
\end{block}

Let's build a Python program where we execute the concrete steps of the algorithm for the sample numbers 42 and 30.

\end{frame}


\begin{frame}

\frametitle{Calculations following Euclid's algorithm for GCD.} 


	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/interactive_euclid.py}

\end{frame}

\begin{frame}
\frametitle{Assignments, values \& expressions.}

Let's understand all aspects of the Python code in this example.
\begin{itemize}
\item \emc{Statements} perform an action within the program. In this example all code lines are statements.
\item \emc{Assignments} are statements that assign an expression (right hand side of $=$) to a variable with a number in the program (left hand side of $=$). 
Eg.\ \mint{python}{a = 42} assigns $42$ to the named variable \texttt{a}.
\item \emc{Expressions} are fragments of code that return a computed quantity.
\item \emc{Values} are expressions that return a constant, eg.\ \texttt{42} and \texttt{30.}
\item More generally \emc{arithmetic expressions} such as \texttt{b - a} perform a computation and return its result. They can be nested arbitrarily.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Some Python idioms.}

\begin{itemize}
	\item The order of evaluation of arithmetic expressions follows the \emc{usual precedence rules} of integer arithmetic, eg. \texttt{2+3*4} is computed as \texttt{2+(3*4) = 14}. You may force a different order of evaluation by using parenthesis, eg. \texttt{(2+3)*4 = 20}.
	\item Python allows for multiple \emc{simultaneous assignments}. Eg.\ lines 2--3 could be expressed as:
	\mint{python}{a, b = 42, 30}
	All expressions on the right hand-side are first evaluated before any assignment occurs.
	\item Python allows for \emc{reusing names} in the left-hand side of an assignment as in line 10.
	\mint{python}{b = b - a}
	Only \emc{reuse variable names if they represent the same} high-level concept.

\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Types \& Programming Languages. (I)}

Python is a strongly typed and dynamically typed language. 
\begin{itemize}
\item \emc{Strongly typed}: Every variable, or expression has a \emc{type} associated with it. All expressions in our example program are of type \emc{int} representing integers. Only operations supported by this type can be performed on variables or expressions of that type.
\item \emc{Dynamically typed}: While the program runs the types of objects are tracked, and operations are checked before being applied to ensure they are permitted. 
\end{itemize}

\vspace{5mm}
In contract \emc{statically typed} languages run this check before the program executes. However, to decide \emc{type-safety} before execution they \emc{lose expressiveness} or require \emc{type annotations}.

\end{frame}

\begin{frame}
\frametitle{Types \& Programming Languages. (II)}

\begin{block}{Types and formal methods}
Type systems are the most popular \emc{formal methods} that aid program correctness. They ensure only permissible operations are executed eliminate a large number of potential trivial bugs. But are \emc{not a substitute for testing} or further \emc{verification} for correctness.
\end{block}

\end{frame}

\begin{frame}
\frametitle{The Python \texttt{int} integer type} 

The type \emc{int} is primitive, in that the Python language itself knows about it out of the box. It can represent \emc{integers of arbitrary length} (unlike other languages), and supports:
\begin{itemize}
\item The arithmetic operators $+$, $-$, $*$ and $**$ (to the power) return integers.
\item The integer division $//$ and remainder operator $\%$ also return integers.
\item Division, but does not return an integer!
\item The function \texttt{int(x)} returns the integer representation of \texttt{x} (if it exists).
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Primitive and user-defined types} 

Python supports out-of-the-box a number of types, including integers, complex numbers, real numbers (\texttt{float}), truth values (\texttt{bool}), strings of characters (\texttt{str}), and many data structures.

\vspace{5mm}
A \emc{full list of all supported operations} can be found in the documentation for all primitive types. \emc{Study it} carefully. \url{https://docs.python.org/3/library/stdtypes.html}.


\begin{block}{User-defined types and abstraction}
High-level programming languages allow programmers to define their own types, associated with their own data and permitted operations. This is a key feature that makes programming in such languages expressive---and closer to the intent of the programmer---and free of the need to reflect in very low-level types, minimizing mistakes.
\end{block}

\end{frame}

\begin{frame}[fragile]
\frametitle{Controlling the execution of programs.} 

So far we have used Python as a \emc{glorified calculator}. 

\vspace{2mm}
We had to interpret ourselves the algorithmic commands relating to doing \emc{different operations depending on conditions}, and \emc{repeating operations until a condition occurs}.

\vspace{2mm}
\begin{itemize}
	\item \emc{Conditional execution} of commands can be achieved by using the \texttt{if ... then ...} control structure taking the form:
\begin{Verbatim}[fontsize=\scriptsize]
if (condition):
    block of statements 1.
else:
    block of statements 2.
\end{Verbatim}

	\item \emc{Repeated execution} while a condition holds may be achieved thorugh the \texttt{while ... } control structure taking the form:
\begin{Verbatim}[fontsize=\scriptsize]
while (condition):
    block of statements 1.
\end{Verbatim}


\end{itemize}

\end{frame}


\begin{frame}

\frametitle{Automatic program control for Euclid's algorithm.} 


	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_euclid.py}

\end{frame}

\begin{frame}

\frametitle{Loops, and the while control structure.} 
\end{frame}

\begin{frame}

\frametitle{Conditional execution with the if control structure.} 
\end{frame}


\begin{frame}
\frametitle{Euclid as a function} 


	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid.py}

\end{frame}

\begin{frame}
\frametitle{Re-using code through functions.}
\end{frame}

\begin{frame}
\frametitle{The `scope' of variables.}
\end{frame}


\begin{frame}
\frametitle{The DRY principle.}
\end{frame}

\begin{frame}
\frametitle{Euclid as a function and unit test} 

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_test.py}

\end{frame}


\begin{frame}
\frametitle{What makes a good test?}
\end{frame}

\begin{frame}
\frametitle{When to write the test?}
\end{frame}


\begin{frame}
\frametitle{The `happy path', errors and exceptions.}
\end{frame}

\begin{frame}
\frametitle{Raising an exception upon error.} 

	\inputminted[
		highlightlines={3-4},
		firstline=1,
		lastline=10,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

\end{frame}

\begin{frame}
\frametitle{How to test \& handle exceptions.}

	\inputminted[
		firstline=19,
		lastline=29,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

\end{frame}

\begin{frame}
\frametitle{The try / except / finally control structure.}
\end{frame}


\begin{frame}
\frametitle{Detect errors at a low level, handle them at a high level.}
\end{frame}


\begin{frame}
\frametitle{Idiomatic pytest.}

	\inputminted[
		firstline=31,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

\end{frame}


\begin{frame}
\frametitle{The practice of refactoring.}
\end{frame}

\section{Algorithmic complexity}

\begin{frame}
\frametitle{How many iterations does the GCD algorithm take?}
\end{frame}


\begin{frame}
\frametitle{Euclid's algorithm using modulo operation (\%).}

	\inputminted[
		lastline=14,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/mod_function_euclid_exc.py}

\end{frame}

\begin{frame}
\frametitle{Cost of modulo and multiple assignment?}
\end{frame}


\begin{frame}
\frametitle{Understanding the int type.}
\end{frame}

\section{Algorithms on `real' numbers}

\begin{frame}
\frametitle{The float type and float variables}
\end{frame}

\begin{frame}
\frametitle{How to test a square root function.}

	\inputminted[
		lastline=14,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_dummy.py}

\end{frame}

\begin{frame}
\frametitle{Heron's method for computing square roots}
\end{frame}

\begin{frame}
\frametitle{Heron's method.}

	\inputminted[
		firstline=18,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt.py}

\end{frame}

\begin{frame}
\frametitle{The problem of termination \& infinite loops.}
\end{frame}

\begin{frame}
\frametitle{Will Heron's method terminate?}

Lemma 1. Heron's approximation to the square root bounds the square root from above. Namely, $\forall x, g. \qquad \frac{1}{2}(g + \frac{x}{g}) \geq \sqrt{x}$.
Proof. $\Rightarrow g^2 - 2g\sqrt{x}+(\sqrt{x})^2 \geq 0$ 
$\Rightarrow (\sqrt{x} - g)^2 \geq 0$. QED.

Theorem 1. Subsequent approximations $g_{i+1} = \frac{1}{2} (g_i + \frac{x}{g_i})$ approximate $\sqrt{x}$ increasingly better. Namely, $|g_{i+1} - \sqrt{x}| < |g_{i} - \sqrt{x}|$. (Where $g_0 = \frac{1}{2}(x + 1)$).
Proof. (Due to lemma 1.) 
$\Rightarrow g_{i+1} - \sqrt{x} < g_{i} - \sqrt{x}$
$\Rightarrow g_{i+1} < g_{i}$
$\Rightarrow \frac{1}{2} (g_i + \frac{x}{g_i}) < g_{i}$
$\Rightarrow g_i^2 + (\sqrt{x})^2 < 2g_i^2$
$\Rightarrow 0 < g_i^2 - (\sqrt{x})^2$
$\Rightarrow 0 < (g_i - \sqrt{x})(g_i + \sqrt{x})$. True by lemma 1. QED.
\end{frame}

\begin{frame}
\frametitle{Ensure progress.}

	\inputminted[
		firstline=31,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_assert.py}

\end{frame}

\begin{frame}
\frametitle{Check invariants within your program.}

Different from runtime exceptions.
\end{frame}


\begin{frame}
\frametitle{Understanding float precision.}

	\inputminted[
		firstline=12,
		lastline=28,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_assert.py}

\end{frame}

\begin{frame}
\frametitle{Always prefer built in functions and standard libraries.}

Do \mint{python}{x ** 0.5}

\end{frame}

\begin{frame}
\frametitle{Understanding functions.}
\end{frame}



% ---------------------------------

\section{Cruft}

\begin{frame}[fragile]
\frametitle{Verbatim environments} 

How to run tests:
\begin{minted}{bash}
$ pytest -vs --doctest-modules
\end{minted}

\vspace{5mm}  

The example of a Verbatim fragment:
\scriptsize %change the font size. You can \scriptsize to get a smaller font.
\begin{verbatim}
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.2.1, py-1.4.34, pluggy-0.4.0 -- 
c:\users\george\appdata\local\programs\python\python35\python.exe
cachedir: .cache
rootdir: C:\Users\george\Desktop\projects\Design_and_Professional_Skills\
Docs\pipeline, inifile:
collecting ... collected 2 items

hello_world_doc.py::hello_world_doc.hello_world PASSED
test_hello_world.py::test_hello_world PASSED

========================== 2 passed in 0.26 seconds ===========================
\end{verbatim}

\end{frame}

\begin{frame}
\frametitle{Inline references}

\bibentry{kernighan1999practice}

\end{frame}

\bibliographystyle{alpha}
\nobibliography{references}

\end{document}