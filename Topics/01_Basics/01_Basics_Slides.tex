\documentclass{beamer} % [aspectratio=169]
\usetheme{ucl}
\setbeamercolor{banner}{bg=brightblue}
\setbeamersize{description width=2em}
\setbeamertemplate{navigation symbols}{\vspace{-2ex}} 

\usepackage[T1]{fontenc} % Turn Â£ into $
\usepackage{minted}
\usemintedstyle{emacs}

\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{url}

\usepackage{natbib}
\usepackage{bibentry}
\usepackage{url}

\newcommand\emc[1]{\textcolor{brightblue}{\textbf{#1}}}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\author{Prof.\ George Danezis \\ University College London, UK}
\title{Basics of Computer Programming \\ \& Software Engineering.}
\subtitle{ENGS102P: Design and Professional Skills }
% \institute{}
\date{Term 1, 2017}


\begin{document}
\nobibliography*


\frame{
\titlepage
}

\section{Introduction}

\frame{
\frametitle{Introducing ENGS102P.}

The ENGS102P `Design and Professional Skills' course has 3 objectives:
\begin{itemize}
\item Teach the basics of \emc{programming in Python}.
\item Introduce basic \emc{Computer Science} concepts.
\item Accustom you to basic \emc{Software Engineering} practices.
\item Expose you to key \emc{ethical and social debates} surrounding computing.
\end{itemize}

} 


\frame{
\frametitle{What is Computer Science \& Software Engineering?}

Computer Science:
\begin{itemize}
\item Studies the nature of \emc{information, computation, complexity} of algorithms, and their \emc{correctness}.
\item Deep mathematical foundations, including logic, algebra and probability theory.
\end{itemize}

Software Engineering:
\begin{itemize}
\item Studies how teams can repeatably \emc{build high quality, correct, usable and efficient software}, to meet \emc{people's needs}.
\item Programming is a foundational and important part of it.
\end{itemize}

The two are interlinked, and we will study them together.
} 

\frame{
\frametitle{Programming \& languages (I).}

Programming \& Programmability: 
\begin{itemize}
	\item A device is programmable if it allows a programmer (developer, engineer) to \emc{alter its behavior}. This is the act of programming.
	\item We usually think of a device as programmable, when the \emc{program itself takes the form or information}, rather than physical modification.
	\item A computer is the \emc{ultimate programmable device}, and can execute all computations. Simpler ones include video recording devices, microwave ovens, and alarm clocks.
	\item \emc{Programming is specializing} a device to solve \emc{a problem that people have}.
\end{itemize}
}

\frame{
\frametitle{Programming \& languages (II).}

Programming Languages:
\begin{itemize}
	\item The \emc{information describing the program} (code), is expressed in a programming language.
	\item \emc{Trivial} programming languages: button presses to program an alarm clock. They are very \emc{low-level ways}, and lead to errors and inflexibility.
	\item Full computers are programmed in \emc{higher-level formal languages}. Programmers may express their intent directly, build complex abstractions, and compose programs from smaller fragments.
	\item Programming languages are formal languages but also \emc{human languages}. Programmers, use them to \emc{express and communicate their intent}.
\end{itemize}

}


\frame{
\frametitle{Why Python?} 
\begin{itemize}
	\item \emc{Real-world}, widely used programming language (5th in TIOBE ranking.)
	\item \emc{Multi-paradigm}: scripting, procedural, functional elements, object oriented, generics.
	\item Extensive \emc{eco-system} of tools and libraries. Great documentation.
	\item Significant \emc{industrial uses}.
	\item \emc{High-productivity}, and perfect for rapid prototyping.
\end{itemize}

Other languages you might want to learn:
\begin{itemize}
\item Lower-level: Rust (Hip!), C++, \emc{C}.
\item Static typing: Go (Hip!), \emc{Java}, C\#.
\item Web: Javascript (Hip!).
\item Functional: \emc{Haskell}, Scala (Hip!)
\end{itemize}

}

\begin{frame}[fragile]
\frametitle{Using Python interactively.} 

\begin{itemize}
	\item Install Python (\url{https://www.python.org/about/gettingstarted/})
	\item Open a command line console, and run the Python interpreter.
	\item Type your fist command: \mint{Python}{print("Hello World!")}
	\item You should see it executing!

\begin{Verbatim}[fontsize=\footnotesize]
george$ python3
Python 3.5.2 (default, Nov 17 2016, 17:05:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello World!")
Hello World!
>>>
\end{Verbatim}

\end{itemize}

\end{frame}


\frame{
\frametitle{Key resources and tools.} 

The interactive interpreter is only good for quick experimentation.
\begin{itemize}
	\item \emc{Code editor}: atom (hip!), Sublime (hip last year!), Visual Studio Code. Must haves: Good syntax highlighting, good handling of files \& folders, whitespace, looks very cool.
	\item Browser with \emc{Python Documentation}: \url{https://docs.python.org/3/}. (including \emc{Python tutorial} and \emc{Library reference}.)
	\item \emc{Command line} \& learn how to use it. \url{https://www.lynda.com/Linux-tutorials/Learn-Linux-Command-Line-Basics/435539-2.html}
	\item Q\&A in browser: \emc{Stack Overflow}. \url{https://stackoverflow.com/}
\end{itemize}
}

\frame{
\frametitle{Your well being.} 

\begin{itemize}
\item Approach the physical activity of programming with \emc{professionalism}.
\item Think of the \emc{ergonomics} of your physical environment: chair height, desk, posture, keyboard style, monitor type and positioning.
\item Make sure you \emc{enjoy your working environment}: light, sounds, distractions.
\item \emc{Drink water}. \emc{Take breaks}, at least every hour.
\item \emc{Keep fit}: core muscles support your back and arms. 
\end{itemize}

}

\begin{frame}[fragile]
\frametitle{The `Hello World!' program in Python.} 

Programs live in files. A simple Python program:

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/hello_world.py}

Execute your first program, by running:
\begin{Verbatim}
$ python3 hello_world.py
Hello World!
\end{Verbatim}

\end{frame}

\begin{frame}
\frametitle{Comments and Whitespace.}

Comments are not executed by Python, but form part of your program.
\begin{itemize}
\item Comments \emc{communicate intent} to your future self and others.
\item Express in comments concepts you cannot directly express in code.
\item Prefer to express concepts directly in code!
\item Keep comments local to the relevant code.
\item Do not overcomment, and avoid duplicate, redundant or wrong comments. Every line of comment will have to be maintained in the future.
\end{itemize}

Python is \emc{sensitive to indentation} using whitespace. Use 3 or 4 spaces (not a tab) to indent blocks of code. More about this later \ldots.

\end{frame}

\begin{frame}
\frametitle{How do we know a program does what it should?}

\emc{Correctness is most important problem} in software engineering and computer science!

\vspace{3mm}
\emc{Testing is the key technique} to produce high quality, correct programs. It is an activity that is continuous, and performed in parallel with programming.

\vspace{3mm}
Complimentary techniques for ensuring program correctness include \emc{formal verification}. Those are more expensive, but necessary to reason about very complex problems.

\vspace{3mm}
Finally, formal periodic \emc{code reviews}, or continuous reflection through \emc{pair programming} also improve quality.

\end{frame}


\frame{
\frametitle{Test Code Continuously.} 

\emc{Testing} is the most important technique to gain confidence a program does what it should:
\begin{itemize}
	\item Unit Test every 2-5 lines of code you write. Think how to \emc{test every snippet of code} just before, while, or just after you write it.
	\item Use a mature \emc{tool for testing} your programs. We will use \texttt{pytest}. \url{https://docs.pytest.org/}.
	\item Different testing techniques for code correctness, integration, security, performance and user experience.
	\item Shortcomings of testing: \emc{lack of completeness}.
\end{itemize}

}

\frame{
\frametitle{Testing the `Hello World!' program.} 

\emc{Tests are snippets of code} executing parts of your program. Eg.\ the test of the simple Python program is:

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/test_hello_world.py}

We run the \emc{test suit}, by executing \texttt{pytest test\_hello\_world.py} on the command line.


}

\frame{
\frametitle{Code documentation and its tests. } 

\emc{Code documentation} is not executed, but forms part of the program. It is useful to your future self, or others that want to use part of your program. Hence, \emc{document reusable units of code}.

	\inputminted[
		xleftmargin=1.4em,
		highlightlines={6-7},
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize, 
		linenos
	]{python}{src/hello_world_doc.py}

You must \emc{test code in documentation}. Through \texttt{pytest -vs --doctest-modules test\_hello\_world.py}.

}


\begin{frame}[fragile]

\frametitle{Example of a successful test run. }

Executing \texttt{pytest} runs all tests in functions named \texttt{test\_*} and documentation strings.

\begin{Verbatim}[fontsize=\scriptsize]
$ pytest -vs --doctest-modules src/*hello*.py
============================= test session starts =============================
platform win32 -- Python 3.5.3, pytest-3.2.1, py-1.4.34, pluggy-0.4.0 -- c:\users\george\appdata\local\programs\python\python35\python.exe
cachedir: .cache
rootdir: C:\Users\george\Desktop\projects\Design_and_Professional_Skills\Topics\01_Basics, inifile:
collecting ... collected 3 items

src/test_hello_world.py::test_hello_world PASSED
src/hello_world_doc.py::hello_world_doc.hello_world PASSED
src/test_hello_world.py::test_hello_world PASSED

========================== 3 passed in 0.03 seconds ===========================
\end{Verbatim}

\end{frame}

\frame{
\frametitle{Summary and next steps.}

The rhythm-of-the-programming-business:
\begin{itemize}
	\item \emc{Think} of the problem $\rightarrow$ \emc{Code} feature (2-5 lines) $\rightarrow$ \emc{Write test} for feature $\rightarrow$ Run \emc{all} tests $\rightarrow$ Fix until \emc{all tests pass} $\rightarrow$ Think \ldots
	\item Working programmers \emc{run tests a few times per minute}.
	\item Testing practice imposes an \emc{incremental approach} to software building.
	\item Professional standards: aspire to deliver programs with \emc{zero bugs}. 
	Remember that \emc{`bugs' may cost millions or even kill}.
\end{itemize}

\vspace{5mm}
Still to cover: functions and function calls (\texttt{def}, \texttt{()}), modules (\texttt{from}, \texttt{import}) and a lot more python \ldots

}

\section{Algorithms \& Python}

\begin{frame}
\frametitle{What is an `algorithm'.} 

An algorithm describes a sequence of steps leading to the solution of a computational problem.

\vspace{5mm}
You are familiar with a number of algorithms, from A-level maths:
\begin{itemize}
\item How to perform integer or real number addition, subtraction, multiplication and division by hand.
\item How to find the roots of a quadratic equation $ax^2+bx+c = 0$.
\item How to expand brackets for $(a+b)(c+d) = ?$
\end{itemize}

\begin{block}{Beyond maths \ldots}
Once we express wider parts of the world as information, algorithms can solve more exciting tasks: eg.\ rendering a 3D scene in a computer game, encrypt communications, build interactive social networks on-line, and program cars to drive autonomously.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Euclid's algorithm for computing the GCD. (I)} 

Euclid of Alexandria (300 BC), like many Hellenistic scholars, was interested in properties of integer and rational numbers. 

\vspace{5mm}
Finding the \emc{greatest common denominator} (GCD) allowed them to simplify fractions:

\vspace{5mm}
Eg.\ $\frac{390253}{228769} = \frac{29 \cdot 13457}{17 \cdot 13457} = \frac{29}{17}$ since $GCD(390253, 228769) = 13457$.

\vspace{5mm}
But how to compute the $GCD(\cdot, \cdot)$ function without resorting to factoring the numbers (which turns out to be a hard problem for large numbers)?

\end{frame}

\begin{frame}
\frametitle{Euclid's algorithm for computing the GCD. (II)} 

\begin{block}{Euclid's algorithm for computing the GCD (in prose)}
\begin{itemize}
\item Consider the two integers for which you want to find the GCD.
\item Take the smaller one, and subtract it from the larger one. 
\item Replace the larger one with this result, and keep the smaller one, as your two new numbers. 
\item Repeat until the two numbers are equal. 
\item Once they are, the resulting (equal) numbers are the GCD.  
\end{itemize}
\end{block}

Let's build a Python program where we execute the concrete steps of the algorithm for the sample numbers 42 and 30.

\end{frame}

\begin{frame}
\frametitle{Why Euclid's algorithm works? (I)}

Consider the positive integers $a$ and $b$; express using $a'$ and $b'$:
\begin{align}
a &= a' \cdot gcd(a,b), \\
b &= b' \cdot gcd(a,b),
\end{align}
where $gcd(a',b') = 1.$

Without loss of generality, consider $a > b$. After a single step:
\begin{align}
a'' &= a - b \\ 
    &= (a' - b') \cdot gcd(a,b).
\end{align}

Note that $a''$ is always strictly positive.

\end{frame}

\begin{frame}
\frametitle{Why Euclid's algorithm works? (II)}

We can show that $gcd(a'', b) = gcd(a,b)$.

Proof by contradiction: 

\begin{itemize}
\item We know that gcd(a,b) is a factor of both a'' and b. 
\item So if $gcd(a'', b) > gcd(a,b)$ it must be that:
$gcd(a' - b', b') = c > 1$. 
\item Thus we can rewrite $b' = r \cdot c$ and $a' - b' = r' \cdot c \Leftrightarrow a' = (r' - r) \cdot c $. 
\item However that means that $a'$ and $b'$ are both divisible by $c$. Which contradicts $gcd(a',b') = 1$.
\end{itemize}

Thus by repeatedly applying the steps of the algorithm we keep the gcd in each step constant while reducing the size of $a$ and $b$. Until they are equal to the gcd.

\end{frame}



\begin{frame}

\frametitle{Calculations following Euclid's algorithm for GCD.} 


	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/interactive_euclid.py}

\end{frame}

\begin{frame}
\frametitle{Assignments, values \& expressions.}

Let's understand all aspects of the Python code in this example.
\begin{itemize}
\item \emc{Statements} perform an action within the program. In this example all code lines are statements.
\item \emc{Assignments} are statements that assign an expression (right hand side of $=$) to a variable with a number in the program (left hand side of $=$). 
Eg.\ \mint{python}{a = 42} assigns $42$ to the named variable \texttt{a}.
\item \emc{Expressions} are fragments of code that return a computed quantity.
\item \emc{Values} are expressions that return a constant, eg.\ \texttt{42} and \texttt{30.}
\item More generally \emc{arithmetic expressions} such as \texttt{b - a} perform a computation and return its result. They can be nested arbitrarily.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Some Python idioms.}

\begin{itemize}
	\item The order of evaluation of arithmetic expressions follows the \emc{usual precedence rules} of integer arithmetic, eg. \texttt{2+3*4} is computed as \texttt{2+(3*4) = 14}. You may force a different order of evaluation by using parenthesis, eg. \texttt{(2+3)*4 = 20}.
	\item Python allows for multiple \emc{simultaneous assignments}. Eg.\ lines 2--3 could be expressed as:
	\mint{python}{a, b = 42, 30}
	All expressions on the right hand-side are first evaluated before any assignment occurs.
	\item Python allows for \emc{reusing names} in the left-hand side of an assignment as in line 10.
	\mint{python}{b = b - a}
	Only \emc{reuse variable names if they represent the same} high-level concept.

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Types \& Programming Languages. (I)}

Python is a strongly typed and dynamically typed language. 
\begin{itemize}
\item \emc{Strongly typed}: Every variable, or expression has a \emc{type} associated with it. All expressions in our example program are of type \emc{int} representing integers. Only operations supported by this type can be performed on variables or expressions of that type.
\item \emc{Dynamically typed}: While the program runs the types of objects are tracked, and operations are checked before being applied to ensure they are permitted. 
\end{itemize}

\vspace{5mm}
In contract \emc{statically typed} languages run this check before the program executes. However, to decide \emc{type-safety} before execution they \emc{lose expressiveness} or require \emc{type annotations}.

\end{frame}

\begin{frame}
\frametitle{Types \& Programming Languages. (II)}

\begin{block}{Types and formal methods}
Type systems are the most popular \emc{formal methods} that aid program correctness. They ensure only permissible operations are executed eliminate a large number of potential trivial bugs. But are \emc{not a substitute for testing} or further \emc{verification} for correctness.
\end{block}

\end{frame}

\begin{frame}
\frametitle{The Python \texttt{int} integer type} 

The type \emc{int} is primitive, in that the Python language itself knows about it out of the box. It can represent \emc{integers of arbitrary length} (unlike other languages), and supports:
\begin{itemize}
\item The arithmetic operators $+$, $-$, $*$ and $**$ (to the power) return integers.
\item The integer division $//$ and remainder operator $\%$ also return integers.
\item Division, but does not return an integer!
\item The function \texttt{int(x)} returns the integer representation of \texttt{x} (if it exists).
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Primitive and user-defined types} 

Python supports out-of-the-box a number of types, including integers, complex numbers, real numbers (\texttt{float}), truth values (\texttt{bool}), strings of characters (\texttt{str}), and many data structures.

\vspace{5mm}
A \emc{full list of all supported operations} can be found in the documentation for all primitive types. \emc{Study it} carefully. \url{https://docs.python.org/3/library/stdtypes.html}.


\begin{block}{User-defined types and abstraction}
High-level programming languages allow programmers to define their own types, associated with their own data and permitted operations. This is a key feature that makes programming in such languages expressive---and closer to the intent of the programmer---and free of the need to reflect in very low-level types, minimizing mistakes.
\end{block}

\end{frame}

\begin{frame}[fragile]
\frametitle{Controlling the execution of programs.} 

So far we have used Python as a \emc{glorified calculator}. 

\vspace{2mm}
We had to interpret ourselves the algorithmic commands relating to doing \emc{different operations depending on conditions}, and \emc{repeating operations while a condition holds}.

\vspace{2mm}
\begin{itemize}
	\item \emc{Conditional execution} of commands can be achieved by using the \texttt{if ... then ...} control structure taking the form:
\begin{Verbatim}[fontsize=\scriptsize]
if condition:
    block of statements 1.
else:
    block of statements 2.
\end{Verbatim}

	\item \emc{Repeated execution} while a condition holds may be achieved thorugh the \texttt{while ... } control structure taking the form:
\begin{Verbatim}[fontsize=\scriptsize]
while condition:
    block of statements 1.
\end{Verbatim}

\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Automatic program control for Euclid's algorithm.} 

Refactoring the euclid algorithm to take advantage of \texttt{while} and \texttt{if} control structures.

	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_euclid.py}

\end{frame}


\begin{frame}

\frametitle{Conditions and the \texttt{bool} type.} 

What is the nature of conditions in Pyhton programs?
\begin{itemize}
\item Conditions are just \emc{expressions}, that return a result of type \emc{bool}.
\item A variable of type \texttt{bool} takes one of two values, \emc{True} or \emc{False}.
\item A number of arithmetic operators return a boolean, incl. \texttt{==} for equality, \texttt{<} less than, \texttt{>} greater than, \texttt{!=} not equal, etc.
\item The \texttt{bool(x)} function interpets \texttt{x} as a boolean if possible.
\item Booleans may be linked together through `\emc{and}', `\emc{or}' and `\emc{not}'.
\item Those \emc{lazily} evaluate the expressions until its value is determined.
\end{itemize}

\end{frame}


\begin{frame}

\frametitle{Loops, and the \texttt{while} control structure.} 

	\inputminted[
		firstline= 5,
		lastline=9,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_euclid.py}

Keep re-executing a block until a condition stops holding.
\begin{itemize}
	\item Upon encountering a \texttt{while} the program \emc{evaluates} the condition.
	\item If the condition is \emc{True} it starts executing the statements in the block.
	\item When the block ends, it \emc{continues} back to the \texttt{while} (line 5).
	\item if \emc{False} it skips the block and \emc{breaks} to line 10.
	\item You can explicitely use \texttt{continue} and \texttt{break} in the program.
\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Conditional execution with the \texttt{if} control structure.} 

	\inputminted[
		firstline= 6,
		lastline=9,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_euclid.py}

Execute a block, or another, depending on a condition.
\begin{itemize}
	\item Upon encountering an \texttt{if} the program \emc{evaluates} the condition.
	\item If \emc{True} it executes the first block (line 7).
	\item Else, if \emc{False}, it executes the second block (line 9)
\end{itemize}

\begin{block}{How are blocks defined?}
In Python blocks are defined as a set of statements with the same degree of indentation 
(whitespace). Use 3 or 4 spaces to group blocks together, and do not use any tabs.
\end{block}

\end{frame}

	
\begin{frame}
\frametitle{Euclid as a function.} 

Refactor Euclid's algorithm as a function with two parameters.
	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid.py}

\end{frame}

\begin{frame}
\frametitle{Re-using code through functions. (I)}

Functions allow us to \emc{define blocks of code}, and \emc{reuse} them without copying them.

	\inputminted[
		firstline=1,
		lastline=1,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid.py}


\begin{itemize}
	\item Declare a function through the keyword \texttt{def} followed by a \emc{function name}, and a list of \emc{named parameters} in brackets.
	\item The names parameters are \emc{available within the block} (body) of the function, but not outside (\emc{variable scope}).
	\item The \emc{return} statement \emc{exits} the function, and may \emc{return a value}.	
\end{itemize}

	\inputminted[
		firstline=8,
		lastline=8,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid.py}


\end{frame}


\begin{frame}
\frametitle{Re-using code through functions (II).}

You may call a function, pass to it different parameters, and get the result.

	\inputminted[
		firstline=12,
		lastline=12,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid.py}


\begin{itemize}
	\item You may \emc{apply} any parameters to a function to \emc{call} it.
	\item \emc{Parameters are expressions} that are evaluated before the function is called.
	\item The function call itself is an expression that results in the \emc{value returned} or \emc{None}. 
\end{itemize}

\vspace{3mm}
Functions are key to supporting \emc{abstraction} in programs.

\end{frame}


\begin{frame}
\frametitle{The `scope' of variables.}

\begin{block}{Why Scope variables?}
Scope ensures that the names of variables from different parts of the program do not clash and 
confuse the programmer, by ensuring a degree of `locality'. 
\end{block}

LEGB Rule defines when variables are available to a block (scope):
\begin{itemize}
\item \emc{L, Local}: Names assigned in any way within a function.
\item \emc{E, Enclosing-function locals}: Name in the local scope of any and all statically enclosing functions, from inner to outer.
\item \emc{G, Global (module)}: Names assigned at the top-level of a module file, or by executing a global statement.
\item \emc{B, Built-in (Python)}: Names in the built-in names module.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Abstraction and DRY principles.}

Benjamin C. Pierce in \emph{Types and Programming Languages} (2002):
\begin{block}{The Abstraction Principle}
Each significant piece of functionality in a program should be implemented in \emc{just one place} in the source code. Where similar functions are carried out by distinct pieces of code, it is \emc{generally beneficial} to combine them into one by \emc{abstracting out} the varying parts.
\end{block}

 Andy Hunt and Dave Thomas in \emph{The Pragmatic Programmer} (1999)
\begin{block}{Don't Repeat Yourself (DRY) Principle}
Every piece of knowledge must have a \emc{single, unambiguous, authoritative representation} within a system.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Euclid as a function and unit test} 

Refactor the Euclid Example with \texttt{ax,bx = 42,30} as a test.
	\inputminted[
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_test.py}

\end{frame}


\begin{frame}
\frametitle{What makes a good test? (I)}

Brian W. Kernighan and Rob Pike in  \emph{The Practice of programming} (1999), provide some advice:
\begin{itemize}
	\item \emc{Coverage}, make sure all lines, and code paths are tested.
	\item \emc{Compare} different implementations to check refactoring and refinement.
	\item Test for \emc{boundary conditions}, values and special cases.
	\item Identify and test that \emc{pre- and post- conditions} hold.
	\item Identify and check for \emc{conservation properties}.
	\item Check \emc{error} returns and exceptional paths.
\end{itemize}

\vspace{3mm}
Tests cannot check all possible paths of large programs, but \emc{model checkers} can be used to test paths more efficiently.

\end{frame}

\begin{frame}
\frametitle{What makes a good test? (II)}

Robert C. Martin in \emph{Clean Code} (2008), states the FIRST principles. Tests should be:
\begin{itemize}
	\item \emc{Fast}, since you will run it many times per minute.
	\item \emc{Independent} of each other, to isolate errors easily. 
	\item \emc{Repeatable} in any environment, for production to QA or your laptop.
	\item \emc{Self-Validating} in that they have a boolean output: success or fail.
	\item \emc{Timely}, written \emph{just before} the production code.
\end{itemize}

\vspace{5mm}
What a second, you said \emc{just before} the production code?

\end{frame}

\begin{frame}
\frametitle{When to write the tests? \& Test Driven Development}

\emc{Test Driven Development}: write tests \emc{just before} the production code.

\vspace{2mm}
Robert C. Martin in \emph{Clean Code} (2008), states the \emc{3 laws of TDD}:
\begin{enumerate}
	\item You may not write production code until you code a failing test.
	\item You may not write more of a unit test than is sufficient to fail.
	\item You may not write more production code than is sufficient to pass the currently failing test.
\end{enumerate}

\vspace{2mm}
\begin{block}{The practice of Test Driven Development (TDD)}
\emc{Think} of the problem $\rightarrow$ \emc{Write minimal test} for feature $\rightarrow$ Run \emc{all} tests and see one fail $\rightarrow$ \emc{Minimal code} for feature (2-5 lines) $\rightarrow$ Fix until \emc{all tests pass} $\rightarrow$ Think \ldots
\end{block}

\end{frame}


\begin{frame}
\frametitle{The `happy path', errors and exceptions.}

Users of your code will use it in \emc{invalid ways}, and \emc{exceptional circumstances} will occur.

\vspace{3mm}
Handling errors and exceptions:
\begin{itemize}
	\item Upon an error code should \emc{fail fast}, and \emc{never fail silently}.
	\item Your \emc{code should handle errors and exceptions} that are the result of external factors.
	\item An external factor is \emc{your future self}, using your own code in an unexpected manner.
	\item Handling exceptional paths must not obscure the intent of your program (the \emc{happy path}).
	\item Use \emc{language facilities} to handle errors and exceptions.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Raising an exception upon error.} 

Refactor Euclid to ensure that inputs are positive integers.

	\inputminted[
		highlightlines={3-4},
		firstline=1,
		lastline=10,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

The \emc{raise} keyword \emc{interrupts the flow of the program}, and exits the block with an exception immediately.

\end{frame}

\begin{frame}[fragile]
\frametitle{The \texttt{try / except / finally} control structure.}

To \emc{handle an exception raised} by a block of code we use:
\begin{Verbatim}[fontsize=\scriptsize]
try:
    Block that may `raise' exception ExceptionName.
except ExceptionName as VariableName:
    Block that handles the exception.
finally:
    Block that is always executed.
\end{Verbatim}

\begin{itemize}
	\item The program executes the block in \emc{try} until the block ends.
	\item If the block raises an exception, the execution end, 
	and it is matched to the exception name in the \emc{except} handler.
	\item If the exception matches the block of the exception handler is executed, otherwise the exception is raised further.
	\item In all cases the \emc{finally} block of code is executed.
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{How to test \& handle exceptions.}

A test that ensures the exception handler is activated for invalid input.
	\inputminted[
		firstline=19,
		lastline=29,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

Note that multiple, including generic, \emc{except} blocks may be present.
\end{frame}


\begin{frame}
\frametitle{Detect errors at a low level, handle them at a high level.}

The Python raise mechanism interrupts the flow, and bubbles up the exception to outer calling blocks. Why?
\begin{itemize}
\item Errors are often detected \emc{deep within programs}. Eg.\ a file name does not exist when you are about to open it.
\item At such a low-level when it is \emc{not known how to handle} them.
\item Thus error handling happens at a higher level, when \emc{options for recovery} are known.
\item Use the \emc{finally} for local clean-up upon an error.
\item Do not use exceptions as part of the happy path, and vice versa.
\end{itemize}

\vspace{3mm}
Only \emc{handle errors at a level where you know how to recover}, otherwise raise them up further.

\end{frame}


\begin{frame}
\frametitle{Advanced: Idiomatic pytest.}

The \texttt{pytest} framework provides facilities for testing multiple inputs, and checking that the correct exceptions are raise.
	\inputminted[
		firstline=31,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/subtraction_function_euclid_exc.py}

It uses advanced Python constructs, such as module \texttt{import}, decorators (\texttt{\@}), lists (\texttt{[\ldots]}), and the \texttt{with} control structure. We will study them later in the course.

\end{frame}


\begin{frame}
\frametitle{The practice of refactoring.}

Programs are living things that \emc{evolve}.
\begin{itemize}
\item Programming is a \emc{dynamic activity}: a program is \emc{re-written and re-tested} many times per minute.
\item Evolving the program to increase its quality is called \emc{refactoring}.
\item \emc{Good design} (abtraction and DRY) \& the existence of \emc{good tests} ensure refactoring does \emc{not introduce new errors} in existing code.
\end{itemize}

\begin{block}{Version Control enables fearless refactoring}
What if refactoring breaks your working program? Tests will detect this, but how can you go back to the working previous version? The solution is to use a version control system, such as \texttt{git}, which we will study later.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Give a command-line interface to Euclid.}

One more step of evolution:
	\inputminted[
		firstline=40,
		lastline=52,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/euclid.py}

Take it on faith that \texttt{sys.argv[1 / 2]} are the command line arguments.

\end{frame}

\begin{frame}[fragile]
\frametitle{A few notes on the interface}

How to \emc{run the program}:
\begin{center}
\begin{Verbatim}[fontsize=\scriptsize]
$ python euclid.py 45 5
5
$ python euclid.py 45 -5
Euclid requires positive integers.
\end{Verbatim}
\end{center}
You have written your very first \emc{real complete program}!

\vspace{3mm}
However:
\begin{itemize}
	\item Hard to \emc{test of interface} we built. Use a function.
	\item Prefer to \emc{use a library} to provide command line interfaces.
	\item Anything that is user facing needs \emc{user experience testing}.
\end{itemize}

\end{frame}


\section{The cost of algorithms}

\begin{frame}
\frametitle{How many iterations does the GCD algorithm take?}

Computer Science applies logic and mathematics to reason about the cost of programs.
\begin{itemize}
	\item Consider the computation of \texttt{GCD(2,000,000, 2) = 2}.
	\item At each iteration of the \texttt{while} loop, the second argument (\texttt{2}) will be subtracted from the larger one, until they are equal to the result (\texttt{2}).
	\item How many times do you need to subtract that number? \\ 
	\texttt{2,000,000 / 2}.
	\item The operation is in effect \emc{equivalent to taking the remainder} between the larger and the smaller number. 
\end{itemize}

\vspace{3mm}
Our version of Euclid relies on a very simple minded (and slow) variant of division.

\end{frame}

\begin{frame}[fragile]
\frametitle{Experimental evaluation of programs.}

A \emc{profiler}, tells you the time spent within functions:
\begin{Verbatim}[fontsize=\scriptsize]
$ python -m cProfile euclid.py 2000000 2 | grep "calls\|GCD"
         50028 function calls (48802 primitive calls) in 0.619 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.295    0.295    0.295    0.295 euclid.py:1(GCD)
\end{Verbatim}

A \emc{trace} of the program displays all statements executed:
\begin{Verbatim}[fontsize=\scriptsize]
$ python -m trace -t euclid.py 200000 2 | grep -c "while (a != b)"
100000
\end{Verbatim}

\begin{block}{Use Unix commands}
The examples above make use of UNIX command line tools, such as pipes (\texttt{|}) to route data from one application to another, and \texttt{grep} to pattern match and count occurrences. Learn how to make effective use of such commands to solve problems.
\end{block}

\end{frame}


\begin{frame}
\frametitle{Euclid's algorithm using remainder operation (\%).}

Refactor Euclid to use the remainder operation.
	\inputminted[
		lastline=14,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/mod_function_euclid_exc.py}

\end{frame}

\begin{frame}[fragile]
\frametitle{Evaluate the optimized code.}

In theory only a single iteration should do, which we confirm:
\begin{Verbatim}[fontsize=\scriptsize]
$ python -m cProfile mod_function_euclid_exc.py 2000000 2 | grep "calls\|GCD"
         50028 function calls (48802 primitive calls) in 0.314 seconds
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 mod_function_euclid_exc.py:1(GCD)
$ python -m trace -t mod_function_euclid_exc.py 200000 2 | grep -c "while (b != 0)"
2
\end{Verbatim}

\begin{block}{What is an optimization?}
An optimization of some program, transforms the program into another one, that is in every way correct, but somewhat more performant than the original one. This could be in terms of speed, resources needed such as memory and storage, or volume of external interactions (such as network traffic).
\end{block}

\end{frame}


\begin{frame}
\frametitle{When to optimize for performance.}

\begin{block}{Premature optimization is the root of all evil (Donald Knuth).}
\footnotesize
Programmers \emc{waste time} thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have \emc{a strong negative impact on debugging and maintenance}. We should forget about small efficiencies: \emc{premature optimization is the root of all evil}. Yet we should not pass up our opportunities for big ones.
\end{block}

\begin{itemize}
\item Only optimize code that is within the \emc{critical part} of the program, namely actually affects performance significantly.
\item Only optimize based on \emc{evidence of the problem}, and \emc{evidence of the benefit} from the solution.
\item Keep other code \emc{simple and easy to understand and maintain}.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{The KISS and YAGNI principles.}

Two key engineering and programming principles.

\begin{block}{Keep it simple, stupid (KISS) Principle (US Navy)}
Most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided.
\end{block}

\begin{block}{You Arent Gonna Need It (YAGNI) Principle (XP \& Agile)}
Always implement things when you actually need them, never when you just foresee that you need them.
\end{block}

\emc{Counterbalance} to the `abstraction principle': Only abstract a function when you have more that one concrete example of. It is \emc{hard to abstract from a single, let alone no, example}.

\end{frame}

\section{Algorithms on `real' numbers}

\begin{frame}
\frametitle{The \texttt{float} type and real valued variables.}

\emc{Real numbers cannot all be represented exactly} within a computer, since irrationals may not be represented by integers (think of $\pi$). Instead they use a \emc{floating point notation}.

%>>> import sys
%>>> sys.float_info
%sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.
%2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsi
%lon=2.220446049250313e-16, radix=2, rounds=1)

\begin{itemize}
	\item Values can be denoted as \texttt{float} by using a decimal point:
	\mint{python}{a = 2.0}
	\item An alternative notation specifies the number in exponential form:
	\mint{python}{a = 4e-2}
	denotes $4 \cdot 10^{-2} = 0.04$.
	\item Floats can have a minimum value of $2.2250738585072014e-308$ and a maximum value of $1.7976931348623157e+308$.
	\item The smallest number greater than $1.0$ is $1.0 + 2.220446049250313e-16$.
	\item All computations are therefore \emc{approximate}.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{How to test a square root function.}

We want to write an algorithm to compute the \emc{square root} of a number.

	\inputminted[
		lastline=14,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_dummy.py}

\begin{itemize}
	\item Note we \emc{write the test first}, following the TDD principle.
	\item We assert that the result of \texttt{sqrt} is close, but not equal by some precision. Equality is not reliable to test floats.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Heron's method for computing square roots.}

Hero of Alexandria (c. 10 AD -- c. 70 AD) proposed an an algorithm for computing square roots of positive numbers.

\begin{block}{Heron's Method}
\begin{itemize}
\item Take the number $x$ for which you wish to compute the square root.
\item Assign $r_0 = x$.
\item Repeatedly compute $r_{i+1} = \frac{1}{2} \left( r_i + \frac{x}{r_i} \right)$.
\item Stop after a certain precision is achieved, and return $r_{i+1}$.
\end{itemize}
\end{block}

Note this is a special case of the Newton-Raphson (1690) algorithm for computing zeros of function $f(x) = 0$.

\end{frame}

\begin{frame}
\frametitle{Heron's method.}

	\inputminted[
		firstline=18,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt.py}

\begin{itemize}
	\item Note we compute, and remember the values of \emc{two consecutive steps}, in \texttt{guess} and \texttt{old\_guess} to compute the gain in precision (line 21--23).
	\item We use a \emc{range test} to terminate the process (line 22).
	\item Other tricks include \emc{bounding on both sides} (line 22), and \emc{double assignment} (line 23).
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{The problem of termination \& infinite loops.}

How can you convince yourself that \emc{the condition will eventually become False} as a result of performing the body of the loop?

\vspace{5mm}
In general, can we write a program, that takes as input any program, and decides whether it ever going to terminate or not? (The \emc{Halting Problem}).

\begin{block}{The Halting Problem}
Alan Turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist. A key part of the proof was a mathematical definition of a computer and program, which became known as \emc{a Turing machine}; the halting problem is \emc{undecidable over Turing machines}. % It is one of the first examples of a decision problem.
\end{block}

However, we can analyze specific programs for termination.

\end{frame}

\begin{frame}
\frametitle{Will Heron's method terminate? (I)}

We will prove that every step, after the first step the approximation can only get better, and eventually get within the precision required.

\vspace{3mm}
Lemma 1. Heron's approximation to the square root bounds the square root from above. Namely, 
\[\forall x,g > 0. \quad \frac{1}{2}(g + \frac{x}{g}) \geq \sqrt{x}.\]

Proof. 
\begin{align}
\frac{1}{2}(g + \frac{x}{g}) \geq \sqrt{x} \Leftrightarrow
g^2 - 2g\sqrt{x}+(\sqrt{x})^2 &\geq 0 \Leftrightarrow \\ 
(\sqrt{x} - g)^2 &\geq 0 \qquad \text{QED}.
\end{align}

\end{frame}

\begin{frame}
\frametitle{Will Heron's method terminate? (II)}

Theorem 1. Subsequent approximations $g_{i+1} = \frac{1}{2} (g_i + \frac{x}{g_i})$ approximate $\sqrt{x}$ increasingly better. (Where $g_0 = \frac{1}{2}(x + 1)$). Namely, 
\[|g_{i+1} - \sqrt{x}| < |g_{i} - \sqrt{x}|.\]


Proof.
\begin{align}
|g_{i+1} - \sqrt{x}| < |g_{i} - \sqrt{x}| &\Leftrightarrow \\
g_{i+1} - \sqrt{x} < g_{i} - \sqrt{x} &\Leftrightarrow \quad \text{(Due to lemma 1.)} \\
g_{i+1} < g_{i} \Leftrightarrow 
\frac{1}{2} (g_i + \frac{x}{g_i}) < g_{i} &\Leftrightarrow \\
g_i^2 + (\sqrt{x})^2 < 2g_i^2 \Leftrightarrow
0 < g_i^2 - (\sqrt{x})^2 &\Leftrightarrow \\
0 < (g_i - \sqrt{x})(g_i + \sqrt{x}) &\quad \text{(True by lemma 1). QED.}
\end{align}

\end{frame}


\begin{frame}
\frametitle{Engineering approach to checking progress.}

Ensure your \texttt{while} loops \emc{make progress}, using an \texttt{assert} in the code.

	\inputminted[
		firstline=31,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_assert.py}

In general, \emc{while loops are dangerous} since it is error prone to ensure termination. We will study a better control structure for most cases, the \emc{for} loop.

\end{frame}

\begin{frame}
\frametitle{Check invariants within your program, with \texttt{assert}.}

\begin{definition}\emc{Invariants} are properties of the program, or parts of the program that must always hold true. \emc{Loop invariants} must be true just before and just after each iteration of the loop.
\end{definition}

\begin{itemize}
	\item Eg.\ within the \texttt{while} the new guess for $\sqrt{x}$ is smaller than the previous guess.
	\item Identify such variants and code them within the program using the \emc{assert} keyword, so that they are constantly checked.
	\item Asserts are \emc{different from exceptions}, they catch problems internal to your program (bugs), not due to the environment -- those cannot be handled at runtime.
	\item You can \emc{disable asserts} through the \texttt{-O} Python option.
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Tests \& understanding float precision.}

	\inputminted[
		firstline=12,
		lastline=28,
		xleftmargin=1.4em,
		frame=lines,
		framesep=2mm,
		%baselinestretch=1.2,
		% bgcolor=lightgray,
		fontsize=\footnotesize,
		linenos
	]{python}{src/sqrt_assert.py}

\end{frame}

\begin{frame}
\frametitle{Always prefer built in functions and standard libraries.}

Writing the \texttt{sqrt} function was an exercise. Prefer to \emc{re-use well-tested code}, eg.  for square roots \texttt{x ** 0.5}.
\begin{itemize}
	\item Study the Python standard library: \url{https://docs.python.org/3/library/}.
	\item Study 3rd party (awesome) libraries: \url{https://github.com/vinta/awesome-python}.
	\item Understand how to use \texttt{pip} and Pypi to download libraries: 
	\url{https://pypi.python.org/pypi}.
\end{itemize}

\begin{block}{Keep your code as small as possible (Dan Mayer)}
``The more development I do the more I feel like increased Lines Of Code (LOC), nearly always results in increased bugs.''
\end{block}

\end{frame}

\begin{frame}
\frametitle{Functions good practices.}

Functions help you modularize and re-use your code, if \emc{done right}!
\begin{itemize}
	\item Give your function and their parameters \emc{good names}.
	\item \emc{Only rely on the function parameters} to perform the computation. \emc{Avoid using global variables} since it lowers modularity.
	\item When possible, the result of the computation should only affect the returned value. This property, is called \emc{no side-effect}.
	\item It is `ok' to \emc{affect the state of parameters}, but never affect the global state.
	\item Keep functions \emc{short} (max 20-40 lines), and ensure they each do only \emc{one key thing}. 
	\item All \emc{concepts} within a functions should be at the \emc{same level of abstraction}.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{What makes a good variable name?}

Programming us about \emc{expressing ideas}, and \emc{good names} help a lot.

\begin{itemize}
	\item Chose \emc{long descriptive names} to be used far from where they are defined.
	\item Chose \emc{short names} when they are used locally only.
	\item Chose a consistent way of expressing \texttt{long\_names} or \texttt{LongNames}.
	\item Use the same name to \emc{consistently} refer to the same concept.
	\item Use names that \emc{accurately reflect the purpose} of the variable.
	\item Use \emc{active names} for function, that perform \emc{actions}.
\end{itemize}

For more advice, read Robert C. Martin in \emph{Clean Code} (2008)

\end{frame}


\begin{frame}
\frametitle{Exercises}

\end{frame}


% ---------------------------------

\bibliographystyle{alpha}
\nobibliography{references}

\end{document}
